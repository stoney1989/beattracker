package ch.fhnw.tvver;

import java.io.File;
import java.io.IOException;
import java.util.EnumSet;

import javax.sound.sampled.UnsupportedAudioFileException;

public class StatisticalStreamingBeatDetection extends AbstractBeatTracker {
	
	final  int FREQ      = (int)getSampleRate();
	final  int TIME_SIZE = 1024;
	
	private static float[] energyHistory;
	private static int historyIndex;

	public StatisticalStreamingBeatDetection(File track)throws UnsupportedAudioFileException, IOException {
		super(track, EnumSet.of(Flags.REPORT, Flags.WAVE));
		 energyHistory = new float[ FREQ / TIME_SIZE ];
		 
		 historyIndex = 0;
	}
	
	
	
	
	private static float c = 1.3f;
	
	@Override
	public void run() {
		//System.out.println("asdfasdfasfd");
		float[] buffer = new float[1024];
		
		try {
			while( getSamples(buffer) ){
				float e = calculateInstantSoundEnergy( buffer );
				float E = calculateLocalAverageEnergy();
				
				float V = calculateVariance(E);
				float C = (-0.0025714f * V) + 1.5142857f;
				
				//addEnergyToHistory(e);
				//addBufferToHistory(buffer);
				
				//if(e > (c*E))System.out.println( "Sound Energy: "+e+" Energy Average: "+(c*E) );
				//if(e>(c*E))beat();
				
				
				//System.out.println(c);
				
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}
	
	private float calculateLocalAverageEnergy(){
		float E = 0;		
		for (int i = 0; i < energyHistory.length; i++) {		
			E += energyHistory[i];
		}
		return E / energyHistory.length;
	}
	
	private void addEnergyToHistory( float e ){		
		energyHistory[ historyIndex ] = e;
		historyIndex++;
		if( historyIndex >= energyHistory.length )historyIndex = 0;
	}
	
	private void addBufferToHistory( float[] buffer ){
		System.out.println(historyIndex);
		System.arraycopy(buffer, 0, energyHistory, historyIndex, 1024);
		historyIndex+=1024;
		if( historyIndex >= 44032 )historyIndex = 0;
		//energyHistory[ historyIndex ] = e;
	}
	
	private static float calculateInstantSoundEnergy( float[] buffer ){
		float e = 0;
		for (int i = 0; i < buffer.length; i++) {			
			e+=buffer[i]*buffer[i];
		}
		e/=buffer.length; 
		return (float) Math.sqrt(e) * 100;
	}
	
	private static float calculateVariance(float E){
		float V = 0;
		for (int i = 0; i < energyHistory.length; i++) {
				V += (float)Math.pow( energyHistory[i]-E, 2);	
		}
		return  V / energyHistory.length;
	}

}
